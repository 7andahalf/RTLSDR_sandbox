'''
### Simple Python - RTLSDR script to capture raw data as well as demod FM
# Author: Vinay C K (github.com/7andahalf)
https://www.youtube.com/watch?v=RuZPJMp2Nt0

# prerequisits and Credits for libraries
- Install python wrapper for RTLSDR from https://github.com/roger-/pyrtlsdr

# How to use:
a) To record IQ and FM:
	- edit below var 'sdr.center_freq' to the required FM station
	- run 'python app.py'
	- after recording required samples, the script will exit

	Output:
	- raw IQ sampling: a .wav file that has a name like 'DIRECTDEMOD_20180317_061311Z_102400kHz_IQ.wav'
		format DIRECTDEMOD_<date>_<time>_<freq>_IQ.wav
	- demodulated FM: a .wav file that has a name like 'DIRECTDEMOD_20180317_061311Z_102400kHz_FM.wav'
		format DIRECTDEMOD_<date_time>_<freq>_FM.wav

b) To demod FM from existing IQ.wav file:
	- record raw IQ from other softwares (@ 2.048MSPS if not edit below var) or use a prev IQ.wav generated by this tool
	- run 'python app.py IQ.wav', replace IQ.wav with input 
	- after demod the script will exit

	Output:
	- demodulated FM: a .wav file that has a name like 'IQ_FM.wav'
		format <input_file_name>_FM.wav

Thanks!
'''

from pylab import *
from rtlsdr import *
import numpy as np  
import scipy.signal as signal
from scipy.signal import butter, lfilter
import sys
from scipy.io.wavfile import read, write
import datetime

# configure device
recordFor = 10 # time in seconds
freqOffset = 250000 # The actual recording will be offsetted by this freq 
FMFreq = 98.3e6 # @ freq of FM station?
SDRSampleRate = 2e6 # 2MHz sampling rate
FMBandwidth = 200000 # BW of FM

# obtain IQ data either by capture or from file
samples = None # to store IQ samples
audFileName = None
if(len(sys.argv) > 1):
	# read samples from file
	print "Will read samples from file", sys.argv[1]
	numSamp, data = read(sys.argv[1]) # any faster methods?
	print "File read complete"
	print "Converting to complex IQ form"
	samples = data[:,0] + 1j * data[:,1] # any faster methods?
	print "Conversion complete"
	audFileName = sys.argv[1].split(".")[0] + "_FM.wav"
else:
	# create object for RTLSDR device
	sdr = RtlSdr(serial_number='00000001') # Change serial_number to select different device, it was 1 for me
	sdr.sample_rate = SDRSampleRate
	sdr.center_freq = FMFreq - freqOffset
	sdr.gain = 'auto'

	# read samples
	numSamples = (int(SDRSampleRate * recordFor) / 1024) * 1024 # div and mult bcz can only read a multiple of 1024 samples. why?
	print "Will collect", numSamples, "samples over the duration of", recordFor, "seconds"
	samples = sdr.read_samples(numSamples)
	print "Collection complete"
	normSamples = samples * 1.0 / np.max(np.abs(samples)) 
	write("DIRECTDEMOD_"+datetime.datetime.now().strftime("%Y%m%d_%H%M%S_")+str(int(FMFreq))+"Hz_IQ.wav", SDRSampleRate, np.column_stack((normSamples.real,normSamples.imag)))
	audFileName = "DIRECTDEMOD_"+datetime.datetime.now().strftime("%Y%m%d_%H%M%S_")+str(int(FMFreq))+"Hz_FM.wav"

'''
# show PSD of captured samples
psd(samples, NFFT=1024, Fs=SDRSampleRate/1e6, Fc=(FMFreq-freqOffset)/1e6)
xlabel('Frequency (MHz)')
ylabel('Relative power (dB)')
show()
'''

## FM Demoduation
# convert to baseband: mult by e^(-j*2pi*freq_diff*time)
sig_baseBand = np.array(samples).astype("complex64")
sig_baseBand *= np.exp(-1.0j*2.0*np.pi* freqOffset*np.arange(len(sig_baseBand))/SDRSampleRate)

# limit bandwidth of FM by downsampling
targetFs = FMBandwidth  
jumpIndex = int(SDRSampleRate / targetFs)  
sig_baseBand_bwlim = sig_baseBand[0::jumpIndex]  # skip samples to downsample
Fs_bwlim = SDRSampleRate/jumpIndex # Calculate the new sampling rate

# FM demod by polar discrimination
sig_fmd = sig_baseBand_bwlim[1:] * np.conj(sig_baseBand_bwlim[:-1])  
sig_fm = np.angle(sig_fmd)

# downsample to audio sampling rate of 44k
targetFs = 44100.0  
jumpIndex = int(Fs_bwlim / targetFs)  
Fs_audlim = Fs_bwlim/jumpIndex # Calculate the new sampling rate
sig_aud = sig_fm[0::jumpIndex]

# resize so that max amp = 1
sig_aud *= 1.0 / np.max(np.abs(sig_aud))  

# save .wav of audio
write(audFileName, Fs_audlim, sig_aud)