'''
### Simple Python - RTLSDR script to capture raw data as well as demod FM
# Author: Vinay C K (github.com/7andahalf)
A small demo video: https://youtu.be/cCH-fBXAYAc

# prerequisits and Credits for libraries
- Install python wrapper for RTLSDR from https://github.com/roger-/pyrtlsdr
- math from: http://ultra.sdk.free.fr/docs/DxO/FM%20DEMODULATION%20USING%20A%20DIGITAL%20RADIO%20AND%20DIGITAL%20SIGNAL%20PROCESSING%20Digradio.pdf
- from: https://github.com/zacstewart/apt-decoder
# How to use:
a) To record IQ and NOAA image + demod FM:
	- edit below var 'sdr.center_freq' to the required FM station
	- run 'python app.py'
	- after recording required samples, the script will exit
	- image will be stored as well as displayed

	Output:
	- raw IQ sampling: a .wav file that has a name like 'DIRECTDEMOD_20180317_061311Z_102400kHz_IQ.wav'
		format DIRECTDEMOD_<date>_<time>_<freq>_IQ.wav
	- demodulated FM: a .wav file that has a name like 'DIRECTDEMOD_20180317_061311Z_102400kHz_FM.wav'
		format DIRECTDEMOD_<date_time>_<freq>_FM.wav
	- decoded image 'DIRECTDEMOD_20180317_061311Z_102400kHz_FM.png'

b) To demod FM + NOAA image from existing IQ.wav file:
	- record raw IQ from other softwares (@ 2.048MSPS if not edit below var) or use a prev IQ.wav generated by this tool
	- run 'python app.py IQ.wav', replace IQ.wav with input 
	- after demod the script will exit and show image and save it

	Output:
	- demodulated FM: a .wav file that has a name like 'IQ_FM.wav'
		format <input_file_name>_FM.wav
	- decoded image '<input_file_name>_FM.wav.png'

Thanks!
'''

from pylab import *
from rtlsdr import *
import numpy as np  
import scipy.signal as signal
from scipy.signal import butter, lfilter
import sys
from scipy.io.wavfile import read, write
import datetime
import PIL

# configure device
recordFor = 10 # time in seconds
freqOffset = -30000
FMFreq = 137619408 # @ freq of FM station?
SDRSampleRate = 2.048e6 # 2MHz sampling rate
FMBandwidth = 60000 # BW of FM

# obtain IQ data either by capture or from file
samples = None # to store IQ samples
audFileName = None
if(len(sys.argv) > 1):
	# read samples from file
	print "Will read samples from file", sys.argv[1]
	numSamp, data = read(sys.argv[1]) # any faster methods?
	print "File read complete"
	print "Converting to complex IQ form"
	samples = data[:,1] + 1j * data[:,0] # any faster methods?
	print "Conversion complete"
	audFileName = sys.argv[1].split(".")[0] + "_FM.wav"
else:
	# create object for RTLSDR device
	sdr = RtlSdr(serial_number='00000001') # Change serial_number to select different device, it was 1 for me
	sdr.sample_rate = SDRSampleRate
	sdr.center_freq = FMFreq - freqOffset
	sdr.gain = 'auto'

	# read samples
	numSamples = (int(SDRSampleRate * recordFor) / 1024) * 1024 # div and mult bcz can only read a multiple of 1024 samples. why?
	print "Will collect", numSamples, "samples over the duration of", recordFor, "seconds"
	samples = sdr.read_samples(numSamples)
	print "Collection complete"
	normSamples = samples * 1.0 / np.max(np.abs(samples)) 
	write("DIRECTDEMOD_"+datetime.datetime.now().strftime("%Y%m%d_%H%M%S_")+str(int(FMFreq))+"Hz_IQ.wav", SDRSampleRate, np.column_stack((normSamples.real,normSamples.imag)))
	audFileName = "DIRECTDEMOD_"+datetime.datetime.now().strftime("%Y%m%d_%H%M%S_")+str(int(FMFreq))+"Hz_FM.wav"

## FM Demoduation
# convert to baseband: mult by e^(-j*2pi*freq_diff*time)
sig_baseBand = np.array(samples).astype("complex64")
sig_baseBand *= np.exp(-1.0j*2.0*np.pi* freqOffset*np.arange(len(sig_baseBand))/SDRSampleRate)

# IF filter
lpf = signal.remez(64, [0, FMBandwidth, FMBandwidth+(SDRSampleRate/2-FMBandwidth)/4, SDRSampleRate/2], [1,0], Hz=SDRSampleRate)  
sig_baseBand = signal.lfilter(lpf, 1.0, sig_baseBand)

# limit bandwidth of FM by downsampling
targetFs = FMBandwidth  
jumpIndex = int(SDRSampleRate / targetFs)  
sig_baseBand_bwlim = sig_baseBand[0::jumpIndex]  # skip samples to downsample
Fs_bwlim = SDRSampleRate/jumpIndex # Calculate the new sampling rate

# FM demod by polar discrimination
sig_fmd = sig_baseBand_bwlim[1:] * np.conj(sig_baseBand_bwlim[:-1])  
sig_fm = np.angle(sig_fmd)

# Filter audio
b, a = butter(1, [1800 / (0.5 * Fs_bwlim), 3000 / (0.5 * Fs_bwlim)], btype='band')
sig_fm = lfilter(b, a, sig_fm)

# downsample to audio sampling rate of 44k
targetFs = 11025.0  
Fs_audlim = 20800
sig_aud = signal.resample(sig_fm, int(20800 * len(sig_fm)/Fs_bwlim))

# resize so that max amp = 1
sig_aud *= 1.0 / np.max(np.abs(sig_aud))  

print "Done FM demod"
# save .wav of audio
write(audFileName, Fs_audlim, sig_aud)

## decode image. 
# limit size to multiple of 20800
sig_aud = sig_aud[:20800*int(len(sig_aud) // 20800)]

# get envelope by hilbert
hilb_aud = signal.hilbert(sig_aud)
filtered = signal.medfilt(np.abs(hilb_aud), 5)
reshaped = filtered.reshape(len(filtered) // 5, 5)

# get high low values to quantise
(low, high) = np.percentile(reshaped[:, 2], (0.5, 99.5))
delta = high - low

# quantize pixels
data = np.round(255 * (reshaped[:, 2] - low) / delta)
data[data < 0] = 0
data[data > 255] = 255
digitized = data.astype(np.uint8)
lines = int(len(digitized) / 2080)
matrix = digitized.reshape((lines, 2080))

# create image from matrix
image = PIL.Image.fromarray(matrix)
image.save(audFileName+".png")
image.show()